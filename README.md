# Self-Similar Groups

Contains code which can be used to generate an implementation of certain self-similar groups.

## Class of groups

The code generation will work for any finitely-generated self-similar group with the following additional property.

For any pair of generators `x` and `y` of the self-similar group, each of the restrictions of the element `xy` to the first level must either be a generator, or the trivial element.

## Requirements

The code under `tool` is written in C++20, and uses only the standard library functions.

The code generated by `tool` (which can be found under `src`) is also C++20.
(However, this may be changed in the future to be C++11 compatible.)

## TODO

### Easy

- [ ] add support for namespaces in generated code
- [ ] replace use of `std::unordered_map` with a static hash-table in generated code
- [ ] implementation for `operator<<(std::ostream&, group)` so that group elements can be printed

### Time consuming

- [ ] update code to work for any contracting self-similar group
- [ ] write general code for generating the volume and geodesic growth
- [ ] write good documentation for the tool, and have the tool generate documentation when it writes it's the C++

## Example: Computing Growth Functions

```cpp
#include "fab_gup.hpp"

#include <algorithm>
#include <array>
#include <cstddef>
#include <functional>

#include <iostream>
#include <map>

int main() {
  // maps from an elment to the number of geodesics for that element
  std::map<fab_gup, unsigned long long> old, sphere;

  // there is only one geodesic for the trivial element
  sphere[{}] = 1;

  // generate the first 20 terms
  for (int i = 1; i <= 20; ++i) {
    // this will contain the contents of the sphere of radius i
    std::map<fab_gup, unsigned long long> next;

    for (const auto& [e, count] : sphere) {
      for (const auto& g : {fab_gup::a, fab_gup::a_inverse, fab_gup::b, fab_gup::b_inverse}) {
        auto n = e * g;
        // either n is a geodesic, or it belongs in the sphere of radius i-1 or i-2
        if (!sphere.contains(n) && !old.contains(n)) {
          next[std::move(n)] += count;
        }
      }
    }
    old = std::move(sphere);
    sphere = std::move(next);

    unsigned long long total_geodesics{};
    for (const auto& [e, count] : sphere) {
      total_geodesics += count;
    }

    // write out the length, spherical growth, spherical geodesic growth
    std::cout << i << ", " << sphere.size() << ", " << total_geodesics << std::endl;
  }
}
```

## License

Copyright (c) 2023 Alex Bishop  
Licensed under the MIT license.

